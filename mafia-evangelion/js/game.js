 const GameState ={ROLES:{MAFIA:'mafia',CIVILIAN:'civilian',DETECTIVE:'detective',DOCTOR:'doctor'},PHASES:{LOBBY:'lobby',NIGHT:'night',DAY:'day',VOTING:'voting',RESULTS:'results',GAME_OVER:'game_over'},currentGame:{roomId:null,players:[],roles:{},phase:'lobby',round:0,timeRemaining:0,timer:null,eliminated:[],votes:{},nightActions:{},winner:null}};function initializeGame(config,players) {GameState.currentGame ={roomId:config.roomId || null,players:players || [],roles:{},phase:GameState.PHASES.LOBBY,round:0,timeRemaining:0,timer:null,eliminated:[],votes:{},nightActions:{},winner:null};assignRoles(config);console.log('Game initialized with',players.length,'players');return GameState.currentGame;} function assignRoles(config) {const players =GameState.currentGame.players;const playerCount =players.length;const mafiaCount =Math.max(1,Math.floor(playerCount / 3));const allRoles =[];for (let i =0;i < mafiaCount;i++) {allRoles.push(GameState.ROLES.MAFIA);} if (config.includeDetective) {allRoles.push(GameState.ROLES.DETECTIVE);} if (config.includeDoctor) {allRoles.push(GameState.ROLES.DOCTOR);} const remainingSlots =playerCount - allRoles.length;for (let i =0;i < remainingSlots;i++) {allRoles.push(GameState.ROLES.CIVILIAN);} const shuffledRoles =shuffleArray(allRoles);const roles ={};players.forEach((player,index) => {roles[player.id] =shuffledRoles[index];});GameState.currentGame.roles =roles;return roles;} function startGame() {GameState.currentGame.phase =GameState.PHASES.NIGHT;GameState.currentGame.round =1;startNightPhase();console.log('Game started,round 1,night phase');return {phase:GameState.currentGame.phase,round:GameState.currentGame.round,message:'Game started,night phase has begun'};} function startNightPhase() {GameState.currentGame.phase =GameState.PHASES.NIGHT;GameState.currentGame.nightActions ={};const phaseDuration =120;startPhaseTimer(phaseDuration,endNightPhase);return {phase:GameState.PHASES.NIGHT,round:GameState.currentGame.round,duration:phaseDuration,message:'Night phase has begun. Special roles will perform their actions.'};} function endNightPhase() {const nightResult =processNightActions();if (nightResult.eliminated) {GameState.currentGame.eliminated.push(nightResult.eliminated);} const winner =checkWinConditions();if (winner) {return endGame(winner);} return startDayPhase(nightResult);} function processNightActions() {const actions =GameState.currentGame.nightActions;const result ={eliminated:null,protected:null,investigated:null};const mafiaTargets =Object.entries(actions) .filter(([playerId,action]) => action.type ==='eliminate') .map(([playerId,action]) => action.target);const targetCounts ={};mafiaTargets.forEach(target => {targetCounts[target] =(targetCounts[target] || 0) + 1;});let mafiaTarget =null;let maxVotes =0;Object.entries(targetCounts).forEach(([target,count]) => {if (count > maxVotes) {maxVotes =count;mafiaTarget =target;}});const doctorActions =Object.entries(actions) .filter(([playerId,action]) => action.type ==='protect');const protectedTarget =doctorActions.length > 0 ? doctorActions[0][1].target :null;result.protected =protectedTarget;const detectiveActions =Object.entries(actions) .filter(([playerId,action]) => action.type ==='investigate');if (detectiveActions.length > 0) {const investigatedTarget =detectiveActions[0][1].target;const investigatedRole =GameState.currentGame.roles[investigatedTarget];result.investigated ={target:investigatedTarget,isMafia:investigatedRole ===GameState.ROLES.MAFIA};} if (mafiaTarget && mafiaTarget !==protectedTarget) {result.eliminated =mafiaTarget;} return result;} function startDayPhase(nightResult) {GameState.currentGame.phase =GameState.PHASES.DAY;GameState.currentGame.votes ={};const phaseDuration =180;startPhaseTimer(phaseDuration,startVotingPhase);let dayMessage ='Discuss who might be the Mafia.';if (nightResult.eliminated) {const eliminatedPlayer =GameState.currentGame.players.find(p => p.id ===nightResult.eliminated);if (eliminatedPlayer) {dayMessage =`${eliminatedPlayer.name} was eliminated during the night. ${dayMessage}`;}} else {dayMessage =`No one was eliminated during the night. ${dayMessage}`;} return {phase:GameState.PHASES.DAY,round:GameState.currentGame.round,duration:phaseDuration,message:dayMessage,eliminated:nightResult.eliminated,protected:nightResult.protected};} function startVotingPhase() {GameState.currentGame.phase =GameState.PHASES.VOTING;const phaseDuration =60;startPhaseTimer(phaseDuration,endVotingPhase);return {phase:GameState.PHASES.VOTING,round:GameState.currentGame.round,duration:phaseDuration,message:'Vote for who you suspect is the Mafia.'};} function endVotingPhase() {const votingResult =processVotes();if (votingResult.eliminated) {GameState.currentGame.eliminated.push(votingResult.eliminated);} const winner =checkWinConditions();if (winner) {return endGame(winner);} return startResultsPhase(votingResult);} function processVotes() {const votes =GameState.currentGame.votes;const result ={eliminated:null,voteCounts:{}};Object.values(votes).forEach(targetId => {result.voteCounts[targetId] =(result.voteCounts[targetId] || 0) + 1;});let maxVotes =0;let eliminatedPlayer =null;let tie =false;Object.entries(result.voteCounts).forEach(([targetId,count]) => {if (count > maxVotes) {maxVotes =count;eliminatedPlayer =targetId;tie =false;} else if (count ===maxVotes) {tie =true;}});if (!tie && eliminatedPlayer) {result.eliminated =eliminatedPlayer;} return result;} function startResultsPhase(votingResult) {GameState.currentGame.phase =GameState.PHASES.RESULTS;let resultsMessage ='';if (votingResult.eliminated) {const eliminatedPlayer =GameState.currentGame.players.find(p => p.id ===votingResult.eliminated);if (eliminatedPlayer) {resultsMessage =`${eliminatedPlayer.name} was eliminated by vote.`;}} else {resultsMessage ='No one was eliminated (tie or no votes).';} const phaseDuration =10;startPhaseTimer(phaseDuration,startNextRound);return {phase:GameState.PHASES.RESULTS,round:GameState.currentGame.round,duration:phaseDuration,message:resultsMessage,eliminated:votingResult.eliminated,voteCounts:votingResult.voteCounts};} function startNextRound() {GameState.currentGame.round++;const nightPhaseData =startNightPhase();console.log(`Round ${GameState.currentGame.round} started,night phase`);return {...nightPhaseData,round:GameState.currentGame.round,message:`Round ${GameState.currentGame.round} started,night phase has begun.`};} function checkWinConditions() {const players =GameState.currentGame.players;const roles =GameState.currentGame.roles;const eliminated =GameState.currentGame.eliminated;const survivors =players.filter(player => !eliminated.includes(player.id));let mafiaCount =0;let civilianCount =0;survivors.forEach(player => {if (roles[player.id] ===GameState.ROLES.MAFIA) {mafiaCount++;} else {civilianCount++;}});if (mafiaCount ===0) {return 'civilians';} else if (mafiaCount >=civilianCount) {return 'mafia';} return null;} function endGame(winner) {GameState.currentGame.phase =GameState.PHASES.GAME_OVER;GameState.currentGame.winner =winner;if (GameState.currentGame.timer) {clearInterval(GameState.currentGame.timer);GameState.currentGame.timer =null;} const endMessage =winner ==='mafia' ? 'The Mafia has taken control of NERV. Civilians lose.' :'All SEELE infiltrators have been identified. Civilians win.';console.log('Game over,winner:',winner);return {phase:GameState.PHASES.GAME_OVER,winner:winner,message:endMessage,roles:GameState.currentGame.roles,eliminated:GameState.currentGame.eliminated};} function startPhaseTimer(seconds,callback) {if (GameState.currentGame.timer) {clearInterval(GameState.currentGame.timer);} GameState.currentGame.timeRemaining =seconds;GameState.currentGame.timer =setInterval(() => {GameState.currentGame.timeRemaining--;if (GameState.currentGame.timeRemaining <=0) {clearInterval(GameState.currentGame.timer);GameState.currentGame.timer =null;if (callback && typeof callback ==='function') {callback();}}},1000);return {duration:seconds,timeRemaining:seconds};} function submitNightAction(playerId,actionType,targetId) {if (GameState.currentGame.phase !==GameState.PHASES.NIGHT) {console.error('Cannot submit night action outside of night phase');return false;} if (GameState.currentGame.eliminated.includes(playerId)) {console.error('Eliminated players cannot perform actions');return false;} const playerRole =GameState.currentGame.roles[playerId];if (!isValidAction(playerRole,actionType)) {console.error(`Invalid action ${actionType} for role ${playerRole}`);return false;} GameState.currentGame.nightActions[playerId] ={type:actionType,target:targetId};console.log(`Player ${playerId} submitted ${actionType} action on ${targetId}`);return true;} function submitVote(playerId,targetId) {if (GameState.currentGame.phase !==GameState.PHASES.VOTING) {console.error('Cannot vote outside of voting phase');return false;} if (GameState.currentGame.eliminated.includes(playerId)) {console.error('Eliminated players cannot vote');return false;} GameState.currentGame.votes[playerId] =targetId;console.log(`Player ${playerId} voted for ${targetId}`);return true;} function isValidAction(role,actionType) {switch (actionType) {case 'eliminate':return role ===GameState.ROLES.MAFIA;case 'investigate':return role ===GameState.ROLES.DETECTIVE;case 'protect':return role ===GameState.ROLES.DOCTOR;default:return false;}} function getRoleDescription(role) {switch (role) {case GameState.ROLES.MAFIA:return 'You are a SEELE infiltrator. Eliminate civilians during the night phase. Pretend to be a civilian during the day phase.';case GameState.ROLES.CIVILIAN:return 'You are a loyal NERV employee. Use your deduction skills to identify SEELE infiltrators during day discussions.';case GameState.ROLES.DETECTIVE:return 'You are a NERV security officer. During the night phase,you can investigate one player to learn if they are SEELE or NERV.';case GameState.ROLES.DOCTOR:return 'You are a NERV medical officer. During the night phase,you can protect one player from elimination.';default:return 'Role description not available.';}} function getAvailableActions(playerId) {if (GameState.currentGame.eliminated.includes(playerId)) {return [];} const phase =GameState.currentGame.phase;const role =GameState.currentGame.roles[playerId];if (phase ===GameState.PHASES.NIGHT) {switch (role) {case GameState.ROLES.MAFIA:return ['eliminate'];case GameState.ROLES.DETECTIVE:return ['investigate'];case GameState.ROLES.DOCTOR:return ['protect'];default:return [];}} if (phase ===GameState.PHASES.VOTING) {return ['vote'];} return [];} function generateRoomCode(length =6) {const characters ='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';let result ='';for (let i =0;i < length;i++) {result +=characters.charAt(Math.floor(Math.random() * characters.length));} return result;} function getGameState() {return {roomId:GameState.currentGame.roomId,players:GameState.currentGame.players,phase:GameState.currentGame.phase,round:GameState.currentGame.round,timeRemaining:GameState.currentGame.timeRemaining,eliminated:GameState.currentGame.eliminated,winner:GameState.currentGame.winner};} function shuffleArray(array) {const result =[...array];for (let i =result.length - 1;i > 0;i--) {const j =Math.floor(Math.random() * (i + 1));[result[i],result[j]] =[result[j],result[i]];} return result;} function createRoom(settings) {const joinCode =generateRoomCode();const roomData ={name:settings.roomName || 'Unnamed Operation',joinCode:joinCode,players:[],settings:{playerCount:parseInt(settings.playerCount) || 6,includeDetective:settings.includeDetective !==false,includeDoctor:settings.includeDoctor !==false,timedRounds:settings.timedRounds ===true,publicEliminations:settings.publicEliminations !==false},gameState:'waiting',createdAt:new Date()};return {roomData,joinCode};} function addPlayerToRoom(roomData,player) {if (roomData.players.length >=roomData.settings.playerCount) {throw new Error('Room is full');} const existingPlayer =roomData.players.find(p => p.id ===player.id);if (existingPlayer) {throw new Error('Player already in room');} roomData.players.push(player);return roomData;} function removePlayerFromRoom(roomData,playerId) {const updatedPlayers =roomData.players.filter(p => p.id !==playerId);if (updatedPlayers.length ===0) {return null;} roomData.players =updatedPlayers;const wasHost =roomData.players.some(p => p.id ===playerId && p.isHost);if (wasHost && updatedPlayers.length > 0) {updatedPlayers[0].isHost =true;} return roomData;} window.EvaGame ={initializeGame,startGame,submitNightAction,submitVote,getRoleDescription,getAvailableActions,getGameState,generateRoomCode,createRoom,addPlayerToRoom,removePlayerFromRoom};